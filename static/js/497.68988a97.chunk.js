/*! For license information please see 497.68988a97.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[497],{2306:(e,n,r)=>{r.d(n,{A:()=>v});var s=r(8139),t=r.n(s),o=r(8747),a=r(5043),i=r(9998),d=r(9791),l=r(9841);const c=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return n.filter((e=>null!=e)).reduce(((e,n)=>{if("function"!==typeof n)throw new Error("Invalid Argument Type, must only provide functions, undefined, or null.");return null===e?n:function(){for(var r=arguments.length,s=new Array(r),t=0;t<r;t++)s[t]=arguments[t];e.apply(this,s),n.apply(this,s)}}),null)};var p=r(2643),u=r(3850),m=r(579);const f={height:["marginTop","marginBottom"],width:["marginLeft","marginRight"]};function h(e,n){const r=n[`offset${e[0].toUpperCase()}${e.slice(1)}`],s=f[e];return r+parseInt((0,o.A)(n,s[0]),10)+parseInt((0,o.A)(n,s[1]),10)}const x={[i.kp]:"collapse",[i.ze]:"collapsing",[i.ns]:"collapsing",[i._K]:"collapse show"},v=a.forwardRef(((e,n)=>{let{onEnter:r,onEntering:s,onEntered:o,onExit:i,onExiting:f,className:v,children:y,dimension:b="height",in:g=!1,timeout:w=300,mountOnEnter:k=!1,unmountOnExit:j=!1,appear:A=!1,getDimensionValue:E=h,..._}=e;const C="function"===typeof b?b():b,I=(0,a.useMemo)((()=>c((e=>{e.style[C]="0"}),r)),[C,r]),R=(0,a.useMemo)((()=>c((e=>{const n=`scroll${C[0].toUpperCase()}${C.slice(1)}`;e.style[C]=`${e[n]}px`}),s)),[C,s]),N=(0,a.useMemo)((()=>c((e=>{e.style[C]=null}),o)),[C,o]),T=(0,a.useMemo)((()=>c((e=>{e.style[C]=`${E(C,e)}px`,(0,p.A)(e)}),i)),[i,E,C]),q=(0,a.useMemo)((()=>c((e=>{e.style[C]=null}),f)),[C,f]);return(0,m.jsx)(u.A,{ref:n,addEndListener:l.A,..._,"aria-expanded":_.role?g:null,onEnter:I,onEntering:R,onEntered:N,onExit:T,onExiting:q,childRef:(0,d.am)(y),in:g,timeout:w,mountOnEnter:k,unmountOnExit:j,appear:A,children:(e,n)=>a.cloneElement(y,{...n,className:t()(v,y.props.className,x[e],"width"===C&&"collapse-horizontal")})})}))},5497:(e,n,r)=>{r.r(n),r.d(n,{default:()=>T});var s=r(5043),t=r(8139),o=r.n(t),a=r(7121),i=r(7852),d=r(2306);function l(e,n){return Array.isArray(e)?e.includes(n):e===n}const c=s.createContext({});c.displayName="AccordionContext";const p=c;var u=r(579);const m=s.forwardRef(((e,n)=>{let{as:r="div",bsPrefix:t,className:a,children:c,eventKey:m,...f}=e;const{activeEventKey:h}=(0,s.useContext)(p);return t=(0,i.oU)(t,"accordion-collapse"),(0,u.jsx)(d.A,{ref:n,in:l(h,m),...f,className:o()(a,t),children:(0,u.jsx)(r,{children:s.Children.only(c)})})}));m.displayName="AccordionCollapse";const f=m,h=s.createContext({eventKey:""});h.displayName="AccordionItemContext";const x=h,v=s.forwardRef(((e,n)=>{let{as:r="div",bsPrefix:t,className:a,onEnter:d,onEntering:l,onEntered:c,onExit:p,onExiting:m,onExited:h,...v}=e;t=(0,i.oU)(t,"accordion-body");const{eventKey:y}=(0,s.useContext)(x);return(0,u.jsx)(f,{eventKey:y,onEnter:d,onEntering:l,onEntered:c,onExit:p,onExiting:m,onExited:h,children:(0,u.jsx)(r,{ref:n,...v,className:o()(a,t)})})}));v.displayName="AccordionBody";const y=v;const b=s.forwardRef(((e,n)=>{let{as:r="button",bsPrefix:t,className:a,onClick:d,...c}=e;t=(0,i.oU)(t,"accordion-button");const{eventKey:m}=(0,s.useContext)(x),f=function(e,n){const{activeEventKey:r,onSelect:t,alwaysOpen:o}=(0,s.useContext)(p);return s=>{let a=e===r?null:e;o&&(a=Array.isArray(r)?r.includes(e)?r.filter((n=>n!==e)):[...r,e]:[e]),null==t||t(a,s),null==n||n(s)}}(m,d),{activeEventKey:h}=(0,s.useContext)(p);return"button"===r&&(c.type="button"),(0,u.jsx)(r,{ref:n,onClick:f,...c,"aria-expanded":Array.isArray(h)?h.includes(m):m===h,className:o()(a,t,!l(h,m)&&"collapsed")})}));b.displayName="AccordionButton";const g=b,w=s.forwardRef(((e,n)=>{let{as:r="h2","aria-controls":s,bsPrefix:t,className:a,children:d,onClick:l,...c}=e;return t=(0,i.oU)(t,"accordion-header"),(0,u.jsx)(r,{ref:n,...c,className:o()(a,t),children:(0,u.jsx)(g,{onClick:l,"aria-controls":s,children:d})})}));w.displayName="AccordionHeader";const k=w,j=s.forwardRef(((e,n)=>{let{as:r="div",bsPrefix:t,className:a,eventKey:d,...l}=e;t=(0,i.oU)(t,"accordion-item");const c=(0,s.useMemo)((()=>({eventKey:d})),[d]);return(0,u.jsx)(x.Provider,{value:c,children:(0,u.jsx)(r,{ref:n,...l,className:o()(a,t)})})}));j.displayName="AccordionItem";const A=j,E=s.forwardRef(((e,n)=>{const{as:r="div",activeKey:t,bsPrefix:d,className:l,onSelect:c,flush:m,alwaysOpen:f,...h}=(0,a.Zw)(e,{activeKey:"onSelect"}),x=(0,i.oU)(d,"accordion"),v=(0,s.useMemo)((()=>({activeEventKey:t,onSelect:c,alwaysOpen:f})),[t,c,f]);return(0,u.jsx)(p.Provider,{value:v,children:(0,u.jsx)(r,{ref:n,...h,className:o()(l,x,m&&`${x}-flush`)})})}));E.displayName="Accordion";const _=Object.assign(E,{Button:g,Collapse:f,Item:A,Header:k,Body:y});var C=r(7784);const I=(0,C.A)("CircleCheckBig",[["path",{d:"M21.801 10A10 10 0 1 1 17 3.335",key:"yps3ct"}],["path",{d:"m9 11 3 3L22 4",key:"1pflzl"}]]),R=(0,C.A)("FileText",[["path",{d:"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",key:"1rqfz7"}],["path",{d:"M14 2v4a2 2 0 0 0 2 2h4",key:"tnqrlb"}],["path",{d:"M10 9H8",key:"b1mrlr"}],["path",{d:"M16 13H8",key:"t4e002"}],["path",{d:"M16 17H8",key:"z1uh3a"}]]),N=(0,s.lazy)((()=>r.e(147).then(r.bind(r,9147)))),T=()=>(0,u.jsxs)("div",{className:"container mt-4",children:[(0,u.jsx)(N,{}),(0,u.jsxs)(_,{defaultActiveKey:"0",children:[(0,u.jsxs)(_.Item,{eventKey:"0",children:[(0,u.jsxs)(_.Header,{children:[(0,u.jsx)(I,{className:"me-2"})," ERC20 Protocol"]}),(0,u.jsxs)(_.Body,{children:[(0,u.jsx)("p",{className:"text-muted",children:"The ERC20 protocol is a  widely adopted standard for fungible tokens on the Ethereum blockchain. It defines a set of functions and events that allow for the creation, transfer, and approval of tokens. This protocol ensures interoperability between different tokens and smart contracts."}),(0,u.jsxs)("p",{children:[(0,u.jsx)("strong",{children:"Purpose of the ERC20 Protocol:"})," The ERC20 token standard facilitates the seamless exchange and interoperability of tokens within the Ethereum ecosystem. It enables users to send, receive, and approve token transactions securely and efficiently."]}),(0,u.jsxs)("p",{children:[(0,u.jsx)("strong",{children:"Functions in ERC20 Protocol:"}),(0,u.jsxs)("ul",{children:[(0,u.jsxs)("li",{children:[(0,u.jsx)("code",{children:"totalSupply()"}),": Returns the total supply of tokens in circulation."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("code",{children:"balanceOf(address account)"}),": Retrieves the token balance of a given address."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("code",{children:"transfer(address recipient, uint256 amount)"}),": Transfers a specified amount of tokens from the sender's balance to the recipient."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("code",{children:"approve(address spender, uint256 amount)"}),": Grants permission for another address to spend a specific amount of tokens on behalf of the sender."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("code",{children:"allowance(address owner, address spender)"}),": Returns the remaining amount of tokens that a spender is allowed to spend on behalf of the owner."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("code",{children:"transferFrom(address sender, address recipient, uint256 amount)"}),": Transfers tokens from one address to another, based on prior approval."]})]})]}),(0,u.jsx)("pre",{children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyERC20Token {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n    constructor(string memory _name, string memory _symbol, uint256 initialSupply, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        _totalSupply = initialSupply * (10 ** uint256(decimals)); \n        _balances[msg.sender] = _totalSupply; \n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(recipient != address(0), "ERC20: transfer to the zero address");\n        require(_balances[msg.sender] >= amount, "ERC20: transfer amount exceeds balance");\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(sender != address(0), "ERC20: transfer from the zero address");\n        require(recipient != address(0), "ERC20: transfer to the zero address");\n        require(_balances[sender] >= amount, "ERC20: transfer amount exceeds balance");\n        require(_allowances[sender][msg.sender] >= amount, "ERC20: transfer amount exceeds allowance");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n}'})]})]}),(0,u.jsxs)(_.Item,{eventKey:"1",children:[(0,u.jsxs)(_.Header,{children:[(0,u.jsx)(R,{className:"me-2"})," ERC721 Protocol"]}),(0,u.jsxs)(_.Body,{children:[(0,u.jsxs)("p",{children:[(0,u.jsx)("strong",{children:"Uses:"})," ERC721 is a standard for representing non-fungible tokens (NFTs) on the Ethereum blockchain."]}),(0,u.jsxs)("p",{children:[(0,u.jsx)("strong",{children:"Scope:"})," It provides a standardized interface for creating and managing unique tokens."]}),(0,u.jsxs)("p",{children:[(0,u.jsx)("strong",{children:"Purpose:"})," Enables the creation of digital assets such as collectibles, real estate, and digital art."]}),(0,u.jsxs)("p",{children:[(0,u.jsx)("strong",{children:"MyERC721Token:"})," Implements the ERC721 standard to create unique, non-fungible tokens."]}),(0,u.jsxs)("ul",{children:[(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"name, symbol:"})," Stores the token's name and symbol."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"_owners, _balances:"})," Track ownership and balance of tokens."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"_tokenApprovals, _operatorApprovals:"})," Manage token approvals and operator permissions."]})]}),(0,u.jsx)("p",{children:(0,u.jsx)("strong",{children:"Functions Breakdown:"})}),(0,u.jsxs)("ul",{children:[(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"balanceOf:"})," Returns the number of tokens owned by an address."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"ownerOf:"})," Returns the owner of a specific token ID."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"approve:"})," Allows another address to transfer a token."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"getApproved:"})," Returns the approved address for a specific token."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"setApprovalForAll:"})," Grants or revokes operator approval for all tokens of an owner."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"transferFrom:"})," Transfers a token from one address to another."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"safeTransferFrom:"})," Ensures safe token transfers."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"mint:"})," Creates a new token."]}),(0,u.jsxs)("li",{children:[(0,u.jsx)("strong",{children:"burn:"})," Destroys an existing token."]})]}),(0,u.jsx)("pre",{children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyERC721Token {\n    string public name;\n    string public symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), "Invalid address");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), "Token does not exist");\n        return owner;\n    }\n\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, "Cannot approve to current owner");\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "Not authorized");\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_owners[tokenId] != address(0), "Token does not exist");\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        require(operator != msg.sender, "Cannot approve yourself");\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), "Not authorized");\n        require(to != address(0), "Cannot transfer to zero address");\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        require(to != address(0), "Cannot mint to zero address");\n        require(_owners[tokenId] == address(0), "Token already exists");\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function burn(uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n    }\n}'})]})]})]})]})}}]);
//# sourceMappingURL=497.68988a97.chunk.js.map