/*! For license information please see 512.02a32115.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[512],{512:(e,n,r)=>{r.r(n),r.d(n,{default:()=>a});r(5043);var s=r(457),o=r(1680),t=r(579);const a=()=>(0,t.jsxs)(s.A.Item,{eventKey:"1",children:[(0,t.jsxs)(s.A.Header,{children:[(0,t.jsx)(o.A,{className:"me-2"})," ERC721 Protocol"]}),(0,t.jsxs)(s.A.Body,{children:[(0,t.jsxs)("p",{children:[(0,t.jsx)("strong",{children:"Uses:"})," ERC721 is a standard for representing non-fungible tokens (NFTs) on the Ethereum blockchain."]}),(0,t.jsxs)("p",{children:[(0,t.jsx)("strong",{children:"Scope:"})," It provides a standardized interface for creating and managing unique tokens."]}),(0,t.jsxs)("p",{children:[(0,t.jsx)("strong",{children:"Purpose:"})," Enables the creation of digital assets such as collectibles, real estate, and digital art."]}),(0,t.jsxs)("p",{children:[(0,t.jsx)("strong",{children:"MyERC721Token:"})," Implements the ERC721 standard to create unique, non-fungible tokens."]}),(0,t.jsxs)("ul",{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"name, symbol:"})," Stores the token's name and symbol."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"_owners, _balances:"})," Track ownership and balance of tokens."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"_tokenApprovals, _operatorApprovals:"})," Manage token approvals and operator permissions."]})]}),(0,t.jsx)("p",{children:(0,t.jsx)("strong",{children:"Functions Breakdown:"})}),(0,t.jsxs)("ul",{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"balanceOf:"})," Returns the number of tokens owned by an address."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"ownerOf:"})," Returns the owner of a specific token ID."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"approve:"})," Allows another address to transfer a token."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"getApproved:"})," Returns the approved address for a specific token."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"setApprovalForAll:"})," Grants or revokes operator approval for all tokens of an owner."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"transferFrom:"})," Transfers a token from one address to another."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"safeTransferFrom:"})," Ensures safe token transfers."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"mint:"})," Creates a new token."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("strong",{children:"burn:"})," Destroys an existing token."]})]}),(0,t.jsx)("pre",{children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyERC721Token {\n    string public name;\n    string public symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), "Invalid address");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), "Token does not exist");\n        return owner;\n    }\n\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, "Cannot approve to current owner");\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "Not authorized");\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_owners[tokenId] != address(0), "Token does not exist");\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        require(operator != msg.sender, "Cannot approve yourself");\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), "Not authorized");\n        require(to != address(0), "Cannot transfer to zero address");\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        require(to != address(0), "Cannot mint to zero address");\n        require(_owners[tokenId] == address(0), "Token already exists");\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function burn(uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n    }\n}'})]})]})},1680:(e,n,r)=>{r.d(n,{A:()=>s});const s=(0,r(7784).A)("FileText",[["path",{d:"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",key:"1rqfz7"}],["path",{d:"M14 2v4a2 2 0 0 0 2 2h4",key:"tnqrlb"}],["path",{d:"M10 9H8",key:"b1mrlr"}],["path",{d:"M16 13H8",key:"t4e002"}],["path",{d:"M16 17H8",key:"z1uh3a"}]])},7784:(e,n,r)=>{r.d(n,{A:()=>d});var s=r(5043);const o=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return n.filter(((e,n,r)=>Boolean(e)&&""!==e.trim()&&r.indexOf(e)===n)).join(" ").trim()};var t={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const a=(0,s.forwardRef)(((e,n)=>{let{color:r="currentColor",size:a=24,strokeWidth:d=2,absoluteStrokeWidth:i,className:l="",children:p,iconNode:c,...u}=e;return(0,s.createElement)("svg",{ref:n,...t,width:a,height:a,stroke:r,strokeWidth:i?24*Number(d)/Number(a):d,className:o("lucide",l),...u},[...c.map((e=>{let[n,r]=e;return(0,s.createElement)(n,r)})),...Array.isArray(p)?p:[p]])})),d=(e,n)=>{const r=(0,s.forwardRef)(((r,t)=>{let{className:d,...i}=r;return(0,s.createElement)(a,{ref:t,iconNode:n,className:o(`lucide-${l=e,l.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()}`,d),...i});var l}));return r.displayName=`${e}`,r}}}]);
//# sourceMappingURL=512.02a32115.chunk.js.map