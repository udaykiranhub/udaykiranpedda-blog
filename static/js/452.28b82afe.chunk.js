/*! For license information please see 452.28b82afe.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[452],{457:(n,e,r)=>{r.d(e,{A:()=>I});var s=r(8139),t=r.n(s),o=r(5043),a=r(7121),i=r(7852),d=r(2306);function l(n,e){return Array.isArray(n)?n.includes(e):n===e}const c=o.createContext({});c.displayName="AccordionContext";const u=c;var p=r(579);const m=o.forwardRef(((n,e)=>{let{as:r="div",bsPrefix:s,className:a,children:c,eventKey:m,...h}=n;const{activeEventKey:x}=(0,o.useContext)(u);return s=(0,i.oU)(s,"accordion-collapse"),(0,p.jsx)(d.A,{ref:e,in:l(x,m),...h,className:t()(a,s),children:(0,p.jsx)(r,{children:o.Children.only(c)})})}));m.displayName="AccordionCollapse";const h=m,x=o.createContext({eventKey:""});x.displayName="AccordionItemContext";const f=x,g=o.forwardRef(((n,e)=>{let{as:r="div",bsPrefix:s,className:a,onEnter:d,onEntering:l,onEntered:c,onExit:u,onExiting:m,onExited:x,...g}=n;s=(0,i.oU)(s,"accordion-body");const{eventKey:w}=(0,o.useContext)(f);return(0,p.jsx)(h,{eventKey:w,onEnter:d,onEntering:l,onEntered:c,onExit:u,onExiting:m,onExited:x,children:(0,p.jsx)(r,{ref:e,...g,className:t()(a,s)})})}));g.displayName="AccordionBody";const w=g;const k=o.forwardRef(((n,e)=>{let{as:r="button",bsPrefix:s,className:a,onClick:d,...c}=n;s=(0,i.oU)(s,"accordion-button");const{eventKey:m}=(0,o.useContext)(f),h=function(n,e){const{activeEventKey:r,onSelect:s,alwaysOpen:t}=(0,o.useContext)(u);return o=>{let a=n===r?null:n;t&&(a=Array.isArray(r)?r.includes(n)?r.filter((e=>e!==n)):[...r,n]:[n]),null==s||s(a,o),null==e||e(o)}}(m,d),{activeEventKey:x}=(0,o.useContext)(u);return"button"===r&&(c.type="button"),(0,p.jsx)(r,{ref:e,onClick:h,...c,"aria-expanded":Array.isArray(x)?x.includes(m):m===x,className:t()(a,s,!l(x,m)&&"collapsed")})}));k.displayName="AccordionButton";const j=k,b=o.forwardRef(((n,e)=>{let{as:r="h2","aria-controls":s,bsPrefix:o,className:a,children:d,onClick:l,...c}=n;return o=(0,i.oU)(o,"accordion-header"),(0,p.jsx)(r,{ref:e,...c,className:t()(a,o),children:(0,p.jsx)(j,{onClick:l,"aria-controls":s,children:d})})}));b.displayName="AccordionHeader";const v=b,y=o.forwardRef(((n,e)=>{let{as:r="div",bsPrefix:s,className:a,eventKey:d,...l}=n;s=(0,i.oU)(s,"accordion-item");const c=(0,o.useMemo)((()=>({eventKey:d})),[d]);return(0,p.jsx)(f.Provider,{value:c,children:(0,p.jsx)(r,{ref:e,...l,className:t()(a,s)})})}));y.displayName="AccordionItem";const A=y,E=o.forwardRef(((n,e)=>{const{as:r="div",activeKey:s,bsPrefix:d,className:l,onSelect:c,flush:m,alwaysOpen:h,...x}=(0,a.Zw)(n,{activeKey:"onSelect"}),f=(0,i.oU)(d,"accordion"),g=(0,o.useMemo)((()=>({activeEventKey:s,onSelect:c,alwaysOpen:h})),[s,c,h]);return(0,p.jsx)(u.Provider,{value:g,children:(0,p.jsx)(r,{ref:e,...x,className:t()(l,f,m&&`${f}-flush`)})})}));E.displayName="Accordion";const I=Object.assign(E,{Button:j,Collapse:h,Item:A,Header:v,Body:w})},2306:(n,e,r)=>{r.d(e,{A:()=>g});var s=r(8139),t=r.n(s),o=r(8747),a=r(5043),i=r(9998),d=r(9791),l=r(9841);const c=function(){for(var n=arguments.length,e=new Array(n),r=0;r<n;r++)e[r]=arguments[r];return e.filter((n=>null!=n)).reduce(((n,e)=>{if("function"!==typeof e)throw new Error("Invalid Argument Type, must only provide functions, undefined, or null.");return null===n?e:function(){for(var r=arguments.length,s=new Array(r),t=0;t<r;t++)s[t]=arguments[t];n.apply(this,s),e.apply(this,s)}}),null)};var u=r(2643),p=r(3850),m=r(579);const h={height:["marginTop","marginBottom"],width:["marginLeft","marginRight"]};function x(n,e){const r=e[`offset${n[0].toUpperCase()}${n.slice(1)}`],s=h[n];return r+parseInt((0,o.A)(e,s[0]),10)+parseInt((0,o.A)(e,s[1]),10)}const f={[i.kp]:"collapse",[i.ze]:"collapsing",[i.ns]:"collapsing",[i._K]:"collapse show"},g=a.forwardRef(((n,e)=>{let{onEnter:r,onEntering:s,onEntered:o,onExit:i,onExiting:h,className:g,children:w,dimension:k="height",in:j=!1,timeout:b=300,mountOnEnter:v=!1,unmountOnExit:y=!1,appear:A=!1,getDimensionValue:E=x,...I}=n;const T="function"===typeof k?k():k,C=(0,a.useMemo)((()=>c((n=>{n.style[T]="0"}),r)),[T,r]),R=(0,a.useMemo)((()=>c((n=>{const e=`scroll${T[0].toUpperCase()}${T.slice(1)}`;n.style[T]=`${n[e]}px`}),s)),[T,s]),_=(0,a.useMemo)((()=>c((n=>{n.style[T]=null}),o)),[T,o]),O=(0,a.useMemo)((()=>c((n=>{n.style[T]=`${E(T,n)}px`,(0,u.A)(n)}),i)),[i,E,T]),D=(0,a.useMemo)((()=>c((n=>{n.style[T]=null}),h)),[T,h]);return(0,m.jsx)(p.A,{ref:e,addEndListener:l.A,...I,"aria-expanded":I.role?j:null,onEnter:C,onEntering:R,onEntered:_,onExit:O,onExiting:D,childRef:(0,d.am)(w),in:j,timeout:b,mountOnEnter:v,unmountOnExit:y,appear:A,children:(n,e)=>a.cloneElement(w,{...e,className:t()(g,w.props.className,f[n],"width"===T&&"collapse-horizontal")})})}))},2452:(n,e,r)=>{r.r(e),r.d(e,{default:()=>c});var s=r(5043),t=r(457),o=r(7784);const a=(0,o.A)("CircleCheckBig",[["path",{d:"M21.801 10A10 10 0 1 1 17 3.335",key:"yps3ct"}],["path",{d:"m9 11 3 3L22 4",key:"1pflzl"}]]),i=(0,o.A)("FileText",[["path",{d:"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",key:"1rqfz7"}],["path",{d:"M14 2v4a2 2 0 0 0 2 2h4",key:"tnqrlb"}],["path",{d:"M10 9H8",key:"b1mrlr"}],["path",{d:"M16 13H8",key:"t4e002"}],["path",{d:"M16 17H8",key:"z1uh3a"}]]);var d=r(579);const l=(0,s.lazy)((()=>r.e(1).then(r.bind(r,2001)))),c=()=>(0,d.jsxs)("div",{className:"container mt-4",children:[(0,d.jsx)("h2",{className:"text-center mb-3",children:"Codebase On The Protocols"}),(0,d.jsxs)(t.A,{defaultActiveKey:"0",children:[(0,d.jsxs)(t.A.Item,{eventKey:"0",children:[(0,d.jsxs)(t.A.Header,{children:[(0,d.jsx)(a,{className:"me-2"})," ERC20 Protocol"]}),(0,d.jsxs)(t.A.Body,{children:[(0,d.jsx)("p",{className:"text-muted",children:"The ERC20 protocol is a  widely adopted standard for fungible tokens on the Ethereum blockchain. It defines a set of functions and events that allow for the creation, transfer, and approval of tokens. This protocol ensures interoperability between different tokens and smart contracts."}),(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Purpose of the ERC20 Protocol:"})," The ERC20 token standard facilitates the seamless exchange and interoperability of tokens within the Ethereum ecosystem. It enables users to send, receive, and approve token transactions securely and efficiently."]}),(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Functions in ERC20 Protocol:"}),(0,d.jsxs)("ul",{children:[(0,d.jsxs)("li",{children:[(0,d.jsx)("code",{children:"totalSupply()"}),": Returns the total supply of tokens in circulation."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("code",{children:"balanceOf(address account)"}),": Retrieves the token balance of a given address."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("code",{children:"transfer(address recipient, uint256 amount)"}),": Transfers a specified amount of tokens from the sender's balance to the recipient."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("code",{children:"approve(address spender, uint256 amount)"}),": Grants permission for another address to spend a specific amount of tokens on behalf of the sender."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("code",{children:"allowance(address owner, address spender)"}),": Returns the remaining amount of tokens that a spender is allowed to spend on behalf of the owner."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("code",{children:"decreaseAllowance( address spender,substract value)"}),":Decrease the allowance of a user"]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("code",{children:"increaseAllowance( address spender,adding value)"}),":Increase the allowance of a user ."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("code",{children:"transferFrom(address sender, address recipient, uint256 amount)"}),": Transfers tokens from one address to another, based on prior approval."]})]})]}),(0,d.jsx)("pre",{children:'\n  // SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyERC20Token {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Mint(address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    \n    constructor(string memory _name, string memory _symbol, uint256 initialSupply, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        _totalSupply = initialSupply * (10 ** uint256(decimals)); \n        _balances[msg.sender] = _totalSupply; \n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(recipient != address(0), "ERC20: transfer to the zero address");\n        require(_balances[msg.sender] >= amount, "ERC20: transfer amount exceeds balance");\n        \n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(spender != address(0), "ERC20: approve to the zero address");\n        \n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(sender != address(0), "ERC20: transfer from the zero address");\n        require(recipient != address(0), "ERC20: transfer to the zero address");\n        require(_balances[sender] >= amount, "ERC20: transfer amount exceeds balance");\n        require(_allowances[sender][msg.sender] >= amount, "ERC20: transfer amount exceeds allowance");\n        \n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0), "ERC20: increase allowance for the zero address");\n        _allowances[msg.sender][spender] += addedValue;\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0), "ERC20: decrease allowance for the zero address");\n        require(_allowances[msg.sender][spender] >= subtractedValue, "ERC20: decreased allowance below zero");\n        _allowances[msg.sender][spender] -= subtractedValue;\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n        return true;\n    }\n\n    function mint(address account, uint256 amount) public {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Mint(account, amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) public {\n        require(_balances[msg.sender] >= amount, "ERC20: burn amount exceeds balance");\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        emit Burn(msg.sender, amount);\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n\n\n'})]})]}),(0,d.jsxs)(t.A.Item,{eventKey:"1",children:[(0,d.jsxs)(t.A.Header,{children:[(0,d.jsx)(i,{className:"me-2"})," ERC721 Protocol"]}),(0,d.jsxs)(t.A.Body,{children:[(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Uses:"})," ERC721 is a standard for representing non-fungible tokens (NFTs) on the Ethereum blockchain."]}),(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Scope:"})," It provides a standardized interface for creating and managing unique tokens."]}),(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Purpose:"})," Enables the creation of digital assets such as collectibles, real estate, and digital art."]}),(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"MyERC721Token:"})," Implements the ERC721 standard to create unique, non-fungible tokens."]}),(0,d.jsxs)("ul",{children:[(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"name, symbol:"})," Stores the token's name and symbol."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"_owners, _balances:"})," Track ownership and balance of tokens."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"_tokenApprovals, _operatorApprovals:"})," Manage token approvals and operator permissions."]})]}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"Functions Breakdown:"})}),(0,d.jsxs)("ul",{children:[(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"balanceOf:"})," Returns the number of tokens owned by an address."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"ownerOf:"})," Returns the owner of a specific token ID."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"approve:"})," Allows another address to transfer a token."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"getApproved:"})," Returns the approved address for a specific token."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"setApprovalForAll:"})," Grants or revokes operator approval for all tokens of an owner."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"transferFrom:"})," Transfers a token from one address to another."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"safeTransferFrom:"})," Ensures safe token transfers."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"mint:"})," Creates a new token."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"burn:"})," Destroys an existing token."]})]}),(0,d.jsx)("pre",{children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyERC721Token {\n    string public name;\n    string public symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), "Invalid address");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), "Token does not exist");\n        return owner;\n    }\n\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, "Cannot approve to current owner");\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "Not authorized");\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_owners[tokenId] != address(0), "Token does not exist");\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        require(operator != msg.sender, "Cannot approve yourself");\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), "Not authorized");\n        require(to != address(0), "Cannot transfer to zero address");\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        require(to != address(0), "Cannot mint to zero address");\n        require(_owners[tokenId] == address(0), "Token already exists");\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function burn(uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n    }\n}'})]})]}),(0,d.jsxs)(t.A.Item,{eventKey:"2",children:[(0,d.jsxs)(t.A.Header,{children:[(0,d.jsx)(i,{className:"me-2"})," Simple Lending Protocol"]}),(0,d.jsxs)(t.A.Body,{children:[(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Uses:"})," The Simple Lending Protocol allows users to deposit ETH as collateral, borrow tokens against it, and repay loans to free up collateral."]}),(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Scope:"})," It provides a lending mechanism with liquidation rules to maintain a healthy collateral ratio."]}),(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Purpose:"})," Enables decentralized lending and borrowing with ETH as collateral and a stable token as the borrowed asset."]}),(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"SimpleLending:"})," Implements a lending system with ETH collateral and ERC20 tokens."]}),(0,d.jsxs)("ul",{children:[(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"stableToken:"})," The ERC20 token used for borrowing."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"COLLATERAL_RATIO, LIQUIDATION_RATIO:"})," Defines borrowing and liquidation thresholds."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"ETH_TO_TOKEN_RATE:"})," Conversion rate from ETH to stable tokens."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"loans mapping:"})," Stores user loan details, including collateral and borrowed tokens."]})]}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"Functions Breakdown:"})}),(0,d.jsxs)("ul",{children:[(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"depositCollateral:"})," Allows users to deposit ETH as collateral."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"borrow:"})," Enables users to borrow tokens based on their collateral."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"repay:"})," Allows users to repay borrowed tokens."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"liquidate:"})," Allows the admin to liquidate loans if collateral falls below the threshold."]}),(0,d.jsxs)("li",{children:[(0,d.jsx)("strong",{children:"withdrawCollateral:"})," Enables users to withdraw collateral if there\u2019s no outstanding loan."]})]}),(0,d.jsx)("pre",{children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/access/Ownable.sol";\n\ncontract Token is ERC20 {\n    constructor() ERC20("stableToken", "STK") {\n        _mint(msg.sender, 1000000 * (10 ** uint256(decimals())));\n    }\n}\n\ncontract SimpleLending is Ownable {\n    IERC20 public stableToken;\n    uint256 public constant COLLATERAL_RATIO = 150;\n    uint256 public constant LIQUIDATION_RATIO = 120;\n    uint256 public constant ETH_TO_TOKEN_RATE = 2000;\n\n    struct Loan {\n        uint256 collateralETH;\n        uint256 borrowedTokens;\n    }\n\n    mapping(address => Loan) public loans;\n\n    event Deposited(address indexed user, uint256 amount);\n    event Borrowed(address indexed user, uint256 amount);\n    event Repaid(address indexed user, uint256 amount);\n    event Liquidated(address indexed user);\n\n    constructor(IERC20 _stableToken) {\n        stableToken = _stableToken;\n    }\n\n    function depositCollateral() external payable {\n        require(msg.value > 0, "Deposit amount must be greater than zero");\n        loans[msg.sender].collateralETH += msg.value;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function borrow(uint256 amount) external {\n        Loan storage loan = loans[msg.sender];\n        require(loan.collateralETH > 0, "No collateral deposited");\n        uint256 maxBorrow = (loan.collateralETH * ETH_TO_TOKEN_RATE * 100) / COLLATERAL_RATIO;\n        require(amount <= maxBorrow, "Borrow amount exceeds collateral limit");\n        loan.borrowedTokens += amount;\n        require(stableToken.transfer(msg.sender, amount), "Token transfer failed");\n        emit Borrowed(msg.sender, amount);\n    }\n\n    function repay(uint256 amount) external {\n        Loan storage loan = loans[msg.sender];\n        require(loan.borrowedTokens >= amount, "Repay amount exceeds loan");\n        require(stableToken.transferFrom(msg.sender, address(this), amount), "Repayment failed");\n        loan.borrowedTokens -= amount;\n        emit Repaid(msg.sender, amount);\n    }\n\n    function liquidate(address user) external onlyOwner {\n        Loan storage loan = loans[user];\n        uint256 requiredCollateral = (loan.borrowedTokens * COLLATERAL_RATIO) / 100;\n        uint256 liquidationThreshold = (loan.borrowedTokens * LIQUIDATION_RATIO) / 100;\n        require(loan.collateralETH * ETH_TO_TOKEN_RATE < liquidationThreshold, "Collateral sufficient");\n        loan.collateralETH = 0;\n        loan.borrowedTokens = 0;\n        emit Liquidated(user);\n    }\n\n    function withdrawCollateral() external {\n        Loan storage loan = loans[msg.sender];\n        require(loan.borrowedTokens == 0, "Outstanding loan exists");\n        uint256 amount = loan.collateralETH;\n        loan.collateralETH = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}'})]})]}),(0,d.jsxs)(t.A.Item,{eventKey:"4",children:[(0,d.jsxs)(t.A.Header,{children:[(0,d.jsx)(i,{className:"me-2"})," Uniswap V1 (2018)"]}),(0,d.jsxs)(t.A.Body,{children:[(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Overview:"})," In Uniswap V1, every ERC-20 token was paired directly with ETH."]}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"Swap Process:"})}),(0,d.jsxs)("ul",{children:[(0,d.jsx)("li",{children:"Swap Token A \u2192 ETH."}),(0,d.jsx)("li",{children:"Swap ETH \u2192 Token B."})]}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"Limitations:"})}),(0,d.jsxs)("ul",{children:[(0,d.jsx)("li",{children:"Extra gas fees due to ETH intermediary."}),(0,d.jsx)("li",{children:"No direct token-to-token swaps."})]}),(0,d.jsx)("pre",{children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\ninterface IUniswapV1 {\n    function ethToTokenSwapInput(uint256 minTokens, uint256 deadline) external payable;\n    function tokenToEthSwapInput(uint256 tokensSold, uint256 minEth, uint256 deadline) external;\n}\n\ncontract UniswapV1Swap {\n    address private constant UNISWAP_V1_EXCHANGE =\n        0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14;\n    address private constant TOKEN =\n        0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    IUniswapV1 public uniswapV1;\n\n    constructor() {\n        uniswapV1 = IUniswapV1(UNISWAP_V1_EXCHANGE);\n    }\n\n    function swapTokenForETH(uint256 amountIn, uint256 minEth) external {\n        IERC20(TOKEN).transferFrom(msg.sender, address(this), amountIn);\n        IERC20(TOKEN).approve(UNISWAP_V1_EXCHANGE, amountIn);\n        uniswapV1.tokenToEthSwapInput(amountIn, minEth, block.timestamp + 300);\n    }\n\n    function swapETHForToken(uint256 minTokens) external payable {\n        uniswapV1.ethToTokenSwapInput{value: msg.value}(minTokens, block.timestamp + 300);\n    }\n}'})]})]}),(0,d.jsxs)(t.A.Item,{eventKey:"5",children:[(0,d.jsxs)(t.A.Header,{children:[(0,d.jsx)(i,{className:"me-2"})," Uniswap V2 (2020)"]}),(0,d.jsxs)(t.A.Body,{children:[(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"Improvements:"})}),(0,d.jsxs)("ul",{children:[(0,d.jsx)("li",{children:"Direct ERC-20 to ERC-20 swaps, eliminating ETH as an intermediary."}),(0,d.jsx)("li",{children:"Pair contracts hold reserves of two tokens."}),(0,d.jsx)("li",{children:"Introduced flash swaps for temporary asset borrowing."}),(0,d.jsx)("li",{children:"Enhanced price oracles to prevent manipulation."}),(0,d.jsx)("li",{children:"More efficient gas usage."})]}),(0,d.jsx)("pre",{children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\ncontract UniswapV2Swap {\n    address private constant UNISWAP_V2_ROUTER =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private constant USDT =\n        0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address private constant WETH =\n        0xC02aaa39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    IUniswapV2Router02 public uniswapRouter;\n\n    constructor() {\n        uniswapRouter = IUniswapV2Router02(UNISWAP_V2_ROUTER);\n    }\n\n    function swapUSDTForWETH(uint256 amountIn, uint256 amountOutMin) external {\n        IERC20(USDT).transferFrom(msg.sender, address(this), amountIn);\n        IERC20(USDT).approve(address(uniswapRouter), amountIn);\n        address ;\n        path[0] = USDT;\n        path[1] = WETH;\n        uniswapRouter.swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            msg.sender,\n            block.timestamp + 300\n        );\n    }\n}'})]})]}),(0,d.jsxs)(t.A.Item,{eventKey:"6",children:[(0,d.jsxs)(t.A.Header,{children:[(0,d.jsx)(i,{className:"me-2"})," Automated Market Maker (AMM)"]}),(0,d.jsxs)(t.A.Body,{children:[(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"Gold & Diamond Token:"})}),(0,d.jsxs)("ul",{children:[(0,d.jsx)("li",{children:"GoldToken (GOLD) - 100,000 initial supply"}),(0,d.jsx)("li",{children:"DiamondToken (DIAMOND) - 50,000 initial supply"})]}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"AMM Features:"})}),(0,d.jsxs)("ul",{children:[(0,d.jsx)("li",{children:"Liquidity addition for GOLD and DIAMOND."}),(0,d.jsx)("li",{children:"Swapping GOLD for DIAMOND and vice versa using the constant product formula."}),(0,d.jsx)("li",{children:"0.3% transaction fee applied to swaps."})]}),(0,d.jsxs)("p",{children:[(0,d.jsx)("strong",{children:"Constant Product Formula:"})," \\( x \\times y = k \\)"]}),(0,d.jsx)("pre",{children:"// Example Swap Calculation:\nGold = 1000\nDiamond = 2000\nk = Gold * Diamond = 2,000,000\n\n1. Adding 100 Gold:\n   GoldNew = 1000 + 100 = 1100\n\n2. New Diamond Calculation:\n   DiamondNew = k / GoldNew\n              = 2,000,000 / 1100\n              = 1818.1818\n\n3. Diamonds to User:\n   Diamond - DiamondNew\n   = 2000 - 1818.1818\n   = 181.8182\n\n4. Updated Reserves:\n   Diamonds = 1818.1818"}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"Swap Fee Calculation:"})}),(0,d.jsx)("pre",{children:"amountInFee = (amountIn * 997) / 1000\nnumerator = amountInFee * reserveOut\ndenominator = (reserveIn * 1000) + amountInFee\namountOut = numerator / denominator"}),(0,d.jsx)("pre",{children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport "@openzeppelin/contracts/token/ERC20/ERC20.sol";\n\n// Gold Token (GOLD)\ncontract GoldToken is ERC20 {\n    constructor() ERC20("GoldToken", "GOLD") {\n        _mint(msg.sender, 100000 * 10 ** decimals());\n    }\n}\n\n// Diamond Token (DIAMOND)\ncontract DiamondToken is ERC20 {\n    constructor() ERC20("DiamondToken", "DIAMOND") {\n        _mint(msg.sender, 50000 * 10 ** decimals());\n    }\n}\n\n// Automated Market Maker (AMM) Contract\ncontract AMM {\n    IERC20 public gold;\n    IERC20 public diamond;\n    uint256 public reserveGold;\n    uint256 public reserveDiamond;\n    \n    constructor(address _gold, address _diamond) {\n        gold = IERC20(_gold);\n        diamond = IERC20(_diamond);\n    }\n\n    function addLiquidity(uint256 goldAmount, uint256 diamondAmount) external {\n        gold.transferFrom(msg.sender, address(this), goldAmount);\n        diamond.transferFrom(msg.sender, address(this), diamondAmount);\n        reserveGold += goldAmount;\n        reserveDiamond += diamondAmount;\n    }\n\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) public pure returns (uint256) {\n        require(amountIn > 0 && reserveIn > 0 && reserveOut > 0, "Invalid reserves");\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        return numerator / denominator;\n    }\n\n    function swapGoldForDiamond(uint256 goldAmount) external {\n        uint256 diamondAmount = getAmountOut(goldAmount, reserveGold, reserveDiamond);\n        require(diamondAmount > 0, "Insufficient output amount");\n        \n        gold.transferFrom(msg.sender, address(this), goldAmount);\n        diamond.transfer(msg.sender, diamondAmount);\n        \n        reserveGold += goldAmount;\n        reserveDiamond -= diamondAmount;\n    }\n\n    function swapDiamondForGold(uint256 diamondAmount) external {\n        uint256 goldAmount = getAmountOut(diamondAmount, reserveDiamond, reserveGold);\n        require(goldAmount > 0, "Insufficient output amount");\n        \n        diamond.transferFrom(msg.sender, address(this), diamondAmount);\n        gold.transfer(msg.sender, goldAmount);\n        \n        reserveDiamond += diamondAmount;\n        reserveGold -= goldAmount;\n    }\n}'})]})]}),(0,d.jsxs)(t.A.Item,{eventKey:"7",children:[(0,d.jsxs)(t.A.Header,{children:[(0,d.jsx)(i,{className:"me-2"})," Uniswap Pool Analysis"]}),(0,d.jsxs)(t.A.Body,{children:[(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"Uniswap Liquidity Pool Structure:"})}),(0,d.jsxs)("p",{children:["The Uniswap system is built on three key components: ",(0,d.jsx)("strong",{children:"UniswapPair (Liquidity Pool)"}),",",(0,d.jsx)("strong",{children:"UniswapFactory (Factory)"}),", and ",(0,d.jsx)("strong",{children:"UniswapRouter (Swap Facilitator)"}),". Each plays a crucial role in the decentralized exchange mechanism."]}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"1\ufe0f\u20e3 UniswapPair (Liquidity Pool) \u2192 The Exchange Booth"})}),(0,d.jsxs)("ul",{children:[(0,d.jsx)("li",{children:"This contract acts as the marketplace for token pairs."}),(0,d.jsx)("li",{children:"Users deposit two types of tokens (e.g., USD and EUR) to provide liquidity."}),(0,d.jsx)("li",{children:"The contract automatically determines the exchange rate based on supply and demand."}),(0,d.jsx)("li",{children:"Users can swap between the two tokens using the available liquidity."})]}),(0,d.jsx)("pre",{children:'// UniswapPair.sol\ncontract UniswapPair {\n    address public token0;\n    address public token1;\n    mapping(address => uint256) public reserves;\n\n    event LiquidityAdded(address indexed provider, uint256 amount0, uint256 amount1);\n    event Swapped(address indexed trader, address tokenIn, uint256 amountIn, uint256 amountOut);\n\n    constructor(address _token0, address _token1) {\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    function addLiquidity(uint256 amount0, uint256 amount1) external {\n        IERC20(token0).transferFrom(msg.sender, address(this), amount0);\n        IERC20(token1).transferFrom(msg.sender, address(this), amount1);\n        reserves[token0] += amount0;\n        reserves[token1] += amount1;\n        emit LiquidityAdded(msg.sender, amount0, amount1);\n    }\n\n    function swap(address tokenIn, uint256 amountIn) external {\n        require(tokenIn == token0 || tokenIn == token1, "Invalid token");\n        address tokenOut = (tokenIn == token0) ? token1 : token0;\n        uint256 amountOut = getAmountOut(amountIn, reserves[tokenIn], reserves[tokenOut]);\n        require(amountOut > 0, "Insufficient liquidity");\n        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\n        IERC20(tokenOut).transfer(msg.sender, amountOut);\n        reserves[tokenIn] += amountIn;\n        reserves[tokenOut] -= amountOut;\n        emit Swapped(msg.sender, tokenIn, amountIn, amountOut);\n    }\n}'}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"2\ufe0f\u20e3 UniswapFactory (Factory) \u2192 The Bank That Creates Exchange Counters"})}),(0,d.jsxs)("ul",{children:[(0,d.jsx)("li",{children:"Responsible for deploying new liquidity pools."}),(0,d.jsx)("li",{children:"Creates new UniswapPair contracts for each trading pair (e.g., BTC/ETH)."}),(0,d.jsx)("li",{children:"Ensures each token pair has a unique exchange contract."})]}),(0,d.jsx)("pre",{children:'// UniswapFactory.sol\ncontract UniswapFactory {\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n    event PairCreated(address indexed tokenA, address indexed tokenB, address pair);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\n        require(tokenA != tokenB, "Identical tokens not allowed");\n        require(getPair[tokenA][tokenB] == address(0), "Pair already exists");\n        bytes32 salt = keccak256(abi.encodePacked(tokenA, tokenB));\n        pair = address(new UniswapPair{salt: salt}(tokenA, tokenB));\n        getPair[tokenA][tokenB] = pair;\n        getPair[tokenB][tokenA] = pair;\n        allPairs.push(pair);\n        emit PairCreated(tokenA, tokenB, pair);\n    }\n}'}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"3\ufe0f\u20e3 UniswapRouter (Swap Facilitator) \u2192 The Cashier That Helps You Exchange Money"})}),(0,d.jsxs)("ul",{children:[(0,d.jsx)("li",{children:"Interacts with UniswapPair contracts to execute swaps."}),(0,d.jsx)("li",{children:"Users call the router to swap one token for another."}),(0,d.jsx)("li",{children:"Finds the correct liquidity pool and executes the trade."})]}),(0,d.jsx)("pre",{children:'// UniswapRouter.sol\ncontract UniswapRouter {\n    IUniswapFactory public factory;\n    constructor(address _factory) {\n        factory = IUniswapFactory(_factory);\n    }\n    function swapExactTokens(address tokenA, address tokenB, uint256 amountIn) external {\n        address pair = factory.getPair(tokenA, tokenB);\n        require(pair != address(0), "Pair does not exist");\n        IUniswapPair(pair).swap(tokenA, amountIn);\n    }\n}'}),(0,d.jsx)("p",{children:(0,d.jsx)("strong",{children:"Conclusion:"})}),(0,d.jsx)("p",{children:"This Uniswap model allows decentralized trading between any two tokens without the need for a traditional order book. Liquidity providers earn fees for supplying assets to pools, and traders benefit from automated swaps with fair pricing."})]})]})]}),(0,d.jsx)(l,{})]})}}]);
//# sourceMappingURL=452.28b82afe.chunk.js.map